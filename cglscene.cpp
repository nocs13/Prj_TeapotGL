// Class automatically generated by Dev-C++ New Class wizard
#define GL_GLEXT_PROTOTYPES

#include <iostream>
#include <GL/gl.h>
#include <GL/glu.h>
#include <GL/glext.h>
#include <math.h>
#include <iostream>
#include "cglscene.h"
#include "cglext.h"
#include "cglsl.h"
#include "csmooth.h"


#define PI   3.1415f
#define PI2  (2 * PI)
#define DMAX 1000.0f

#define MAX_TIMEOUT 3000

// class constructor
cGLScene::cGLScene()
{
  q = t = 0.0f;
  d = 200.0f;
  aspect = 1.0f;
  
  light.pos[0] = 130.0;
  light.pos[1] = -200.0;
  light.pos[2] = 120.0;
  light.col[0] = 0.3;  
  light.col[1] = 0.6;  
  light.col[2] = 0.9;  

  shader = NULL;
  
  explosion = false;
  viewlines = false;
}

// class destructor
cGLScene::~cGLScene()
{
  for (cNode* n: nodes)
    delete n;
    
  nodes.clear();
  
  for (cMesh* m: meshes)
    delete m;
    
  meshes.clear();
    
  if (shader) {
    delete shader;
    shader = NULL;
  }
}

void cGLScene::camHorizontal(float a)
{
  q += a;

  if (q < 0.0f)
    q = 0.0f;
  else if (q > PI2)
    q = PI2;

  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  gluPerspective(45.0f, aspect, 0.1f, 1000.0f);

  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  gluLookAt(d * cos(q), d * cos(t), d, 0, 0, 0, 0, 1, 0);

  //std::cout << "Move camera horizontal" << std::endl;
}

void cGLScene::camVertical(float a)
{
  t += a;

  if (t < 0.0f)
    t = 0.0f;
  else if (t > PI2)
    t = PI2;

  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  gluPerspective(45.0f, aspect, 0.1f, 1000.0f);

  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  gluLookAt(d * cos(q), d * cos(t), d, 0, 0, 0, 0, 1, 0);

  //std::cout << "Move camera vertical" << std::endl;
}

void cGLScene::camDistance(float a)
{
  d += a;

  if (d > DMAX)
    d = DMAX;
  else if (d < 0.0f)
    d = 0.0f;

  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  gluPerspective(45.0f, aspect, 0.1f, 1000.0f);

  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  gluLookAt(d * cos(q), d * cos(t), d, 0, 0, 0, 0, 1, 0);

  //std::cout << "Change camera distance" << std::endl;
}

void cGLScene::addModel(const char *path)
{
  if (meshes.size() > 0) {
    std::cerr << "Error mesh already loaded" << std::endl;
    
    return;
  }
      
  cMesh *mesh = new cMesh();
  
  if (!mesh->loadFromObj(path)) {
    std::cerr << "Error loading mesh" << std::endl;
    
    delete mesh;
    
    return;  
  }
  
  std::cout << "Load mesh model. Vertices: " << mesh->getVertexCount()
            << " Faces: " << mesh->getFaceCount() << std::endl;
  
  meshes.push_back(mesh);
}

void cGLScene::insert()
{
  if (meshes.empty()) {
    std::cerr << "Error: No meshes" << std::endl;
    
    return;  
  }
  
  /*if (nodes.size() > 0) {
    std::cerr << "Error: model already inserted in scene" << std::endl;
    
    return;  
  }*/
  
  cMesh *mesh = meshes.back();
  
  if (!mesh) {
    std::cerr << "Invalid mesh" << std::endl;
    
    return;  
  }
  
  int count = nodes.size();
  
  cNode *node = new cNode();
  
  node->setMesh(mesh);
  node->setPosition(count * 10.0f, 0, 0);
  
  nodes.push_back(node);
}

void cGLScene::smooth() 
{
  if (meshes.size() < 1)
    return;
    
  for(auto m: meshes) {
    cSmooth smooth;
    
    //if (smooth.smooth(m->getTFaces(), m->getTFaceCount())) {
    //  smooth.smooth(m);
    //}
    //smooth.smoothRoam(m, 0);
    smooth.smooth001(m, 1);
  }
}

void cGLScene::unsmooth() 
{
  if (meshes.size() < 1)
    return;
    
  for(auto m: meshes) {
    m->resetTFaces(); 
  }
}

void cGLScene::explode() 
{
  if (explosion)
    return;
  
  for (cNode* n: nodes) {
    if (n->getType() == cNode::Type_Mesh) {
      n->hide();
      
      cVec3<float> pos = n->position();
      cExplode* explode = new cExplode(n->getMesh());
      
      cNode* enode = new cNode();
      enode->setExplode(explode);
      enode->setPosition(pos.x(), pos.y(), pos.z());
      simulates.push_back(enode);
    } 
  }
  
  start = ::GetTickCount();
  
  explosion = true;
}

void cGLScene::linemode() 
{
  viewlines = !viewlines;
  
  if (viewlines)
    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
  else
    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
}

void cGLScene::init(int width, int height)
{
  if (height < 1)
    height = 1;

  glViewport(0, 0, width, height);

  glClearColor(0.40f, 0.10f, 0.20f, 0.0f);  
  glClearDepth(1.0);            
  glDepthFunc(GL_LESS);         
  glEnable(GL_DEPTH_TEST);      
  glShadeModel(GL_SMOOTH);      

  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();               

  aspect = (GLfloat)width / (GLfloat)height;
  
  gluPerspective(45.0f, aspect, 0.1f, 1000.0f);

  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();               
  gluLookAt(d * cos(q), d * cos(t), d, 0, 0, 0, 0, 1, 0);
  
  glDisable(GL_CULL_FACE);
  glCullFace(GL_FRONT);
  
  if (!shader) {
    shader = new cGLSL();
    shader->prepare(Shader_0);
  }
}

void cGLScene::resize(int width, int height)
{
  if (height < 1)
    height = 1;
  
  glViewport(0, 0, width, height);
  
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();

  aspect = (GLfloat)width / (GLfloat)height;
  
  gluPerspective(45.0f, aspect, 0.1f, 1000.0f);
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();               
  gluLookAt(d * cos(q), d * cos(t), d, 0, 0, 0, 0, 1, 0);
  
  std::cout << "Window resized " << width << ":" << height << std::endl;
}

void cGLScene::render()
{
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

  glMatrixMode(GL_MODELVIEW);
  //glLoadIdentity();              

  //glTranslatef(0.0f, 0.0f, 0.0f);

  /*glBegin(GL_POINTS);
  glColor3f(1, 1, 1);
  glVertex3f(0, 0, 0);
  glEnd();*/
  
  if (shader) {    
    shader->link();
    shader->setVec3("lpos", light.pos);    
    shader->setVec3("vcol", light.col);    
  }
    
  for (auto n: nodes)
  {
    if (!n->visibility())
      continue;
      
    if (n->getType() == cNode::Type_Mesh) {  
      cMesh *mesh = n->getMesh();
    
      if (!mesh)
        continue;
      
      cVec3<float> pos = n->position();
    
      glLoadIdentity();
      glTranslatef(pos.x(), pos.y(), pos.z());
      gluLookAt(d * cos(q), d * cos(t), d, 0, 0, 0, 0, 1, 0);
    
      draw(mesh);
       
      /*cMesh::Vertex *v = mesh->getVertices();
      cMesh::Face *f = mesh->getFaces();
        
      glBegin(GL_POINTS);
      for (int i = 0; i < mesh->getVertexCount(); i++) {
        glVertex3f(v[i].pos[0], v[i].pos[1], v[i].pos[2]);
      }
      glEnd();
    
      glBegin(GL_TRIANGLES);
      for (int i = 0; i < 300; i++) {
        glVertex3f(v[f[i].fac[0]].pos[0], v[f[i].fac[0]].pos[1], v[f[i].fac[0]].pos[2]);
        glVertex3f(v[f[i].fac[1]].pos[0], v[f[i].fac[1]].pos[1], v[f[i].fac[1]].pos[2]);
        glVertex3f(v[f[i].fac[2]].pos[0], v[f[i].fac[2]].pos[1], v[f[i].fac[2]].pos[2]);
      }
      glEnd();*/
    } 
  }
  
  for (cNode* n: simulates) {
    cExplode* exp = n->getExplode();
      
    if (!exp)
      continue;
        
    cVec3<float> pos = n->position();
    
    glLoadIdentity();
    glTranslatef(pos.x(), pos.y(), pos.z());
    gluLookAt(d * cos(q), d * cos(t), d, 0, 0, 0, 0, 1, 0);

    draw(exp->getChunks(), exp->getChunkCount());
    exp->simulate();
  }
  
  if (shader)
    shader->unlink();
    
  if (explosion) {
    if ((GetTickCount() - start) > MAX_TIMEOUT) {
      explosion = false;
      
      for (cNode* n: simulates)
        delete n;
        
      simulates.clear();
      
      for (cNode* n: nodes)
        if (!n->visibility())
          n->show();
    }
  }
}

void cGLScene::draw(cMesh* m)
{
  /*if (m->getVertexCount() < 1)
    return;
    
  if (m->getFaceCount() > 0)
    draw(m->getVertices(), m->getVertexCount(), m->getFaces(), m->getFaceCount());
  else
    draw(m->getVertices(), m->getVertexCount());*/
    
  if (m->getTFaceCount())
    draw(m->getTFaces(), m->getTFaceCount());
}

void cGLScene::draw(cMesh::Vertex* v, int vc)
{
  draw(v, vc, NULL, 0);
}

void cGLScene::draw(cMesh::Vertex* v, int vc, cMesh::Face* f, int fc)
{
  //int loc;

  //loc = shader->getLocation("a_Vertex");  
  glEnableClientState(GL_VERTEX_ARRAY);
  cGLExt::glVertexPointer(3, GL_FLOAT, sizeof(cMesh::Vertex), (void*) &v->pos);
  //cGLExt::glEnableVertexAttribArray(loc);
  
  glEnableClientState(GL_NORMAL_ARRAY);
  //loc = shader->getLocation("a_Normal"); 
  cGLExt::glNormalPointer(GL_FLOAT, sizeof(cMesh::Vertex), (void*) &v->nor);
  //cGLExt::glEnableVertexAttribArray(loc);
  
  if (f && fc > 0) {
    glDrawElements(GL_TRIANGLES, 3 * fc , GL_UNSIGNED_SHORT, f);
  } else {
    glDrawArrays(GL_TRIANGLES, 0, vc);
  }
  
  glDisableClientState(GL_VERTEX_ARRAY);
  glDisableClientState(GL_NORMAL_ARRAY);  
  //cGLExt::glDisableVertexAttribArray(0);
  //cGLExt::glDisableVertexAttribArray(1);
}
